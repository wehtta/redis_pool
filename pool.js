// Generated by CoffeeScript 1.7.1
(function() {
  var priorityQueue,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __slice = [].slice;

  priorityQueue = function(size) {
    var i, me, slots, total;
    me = {};
    slots = void 0;
    i = void 0;
    total = null;
    size = Math.max(+size | 0, 1);
    slots = [];
    i = 0;
    while (i < size) {
      slots.push([]);
      i += 1;
    }
    me.size = function() {
      i = void 0;
      if (total === null) {
        total = 0;
        i = 0;
        while (i < size) {
          total += slots[i].length;
          i += 1;
        }
      }
      return total;
    };
    me.enqueue = function(obj, priority) {
      var priorityOrig;
      priorityOrig = void 0;
      priority = priority && +priority | 0 || 0;
      total = null;
      if (priority) {
        priorityOrig = priority;
        if (priority < 0 || priority >= size) {
          priority = size - 1;
          console.error("invalid priority: " + priorityOrig + " must be between 0 and " + priority);
        }
      }
      slots[priority].push(obj);
    };
    me.dequeue = function(callback) {
      var obj, sl;
      obj = null;
      i = void 0;
      sl = slots.length;
      total = null;
      i = 0;
      while (i < sl) {
        if (slots[i].length) {
          obj = slots[i].shift();
          break;
        }
        i += 1;
      }
      return obj;
    };
    return me;
  };

  module.exports.Pool = function(factory) {
    var availableObjects, count, createResource, dispense, draining, ensureMinimum, idleTimeoutMillis, log, me, reapInterval, refreshIdle, removeIdle, removeIdleScheduled, removedIdleTimer, scheduleRemoveIdle, waitingClients;
    me = {};
    idleTimeoutMillis = factory.idleTimeoutMillis || 3000;
    reapInterval = factory.reapInterval || 1000;
    refreshIdle = (__indexOf.call(factory, 'refreshIdle') >= 0) ? factory.refreshIdle : true;
    availableObjects = [];
    waitingClients = new priorityQueue();
    count = 0;
    removeIdleScheduled = false;
    removedIdleTimer = null;
    draining = false;
    log = factory.log ? (function(str, level) {
      if (typeof factory.log === 'function') {
        return factory.log(str, level);
      } else {
        return console.log(level + "pool" + factory.name);
      }
    }) : function() {};
    factory.max = parseInt(factory.max, 10);
    factory.min = parseInt(factory.min, 10);
    factory.max = Math.max((isNaN(factory.max) ? 1 : factory.max), 1);
    factory.min = Math.min((isNaN(factory.min) ? 0 : factory.min), factory.max - 1);
    me.acquire = function(callback, priority) {
      if (draining) {
        throw new Error("pool is draining error");
      } else {
        waitingClients.enqueue(callback, priority);
        return dispense();
      }
    };
    dispense = function() {
      var clientCb, waitingCount;
      waitingCount = waitingClients.size();
      log("dispense() clients=" + waitingCount + "available=" + availableObjects, "info");
      if (waitingCount > 0) {
        if (availableObjects.length > 0) {
          availableObjects.shift();
          clientCb = waitingClients.dequeue();
          clientCb(null, availableObjects[0].obj);
        }
        if (count < factory.max) {
          return createResource();
        }
      }
    };
    createResource = function() {
      var clientCb;
      count += 1;
      clientCb = waitingClients.dequeue();
      return factory.create(function(err, client) {
        if (err) {
          console.log("createResource error");
          count -= 1;
          if (clientCb) {
            return clientCb(err, null);
          } else {
            return process.nextTick(function() {
              return dispense();
            });
          }
        } else {
          if (clientCb) {
            return clientCb(null, client);
          } else {
            return me.release(client);
          }
        }
      });
    };
    ensureMinimum = function() {
      var _results;
      _results = [];
      while (!(count >= factory.min)) {
        _results.push(createResource());
      }
      return _results;
    };
    me.release = function(obj) {
      var objWithTimeout;
      if (availableObjects.some(function(objWithTimeout) {
        return objWithTimeout === obj;
      })) {
        return log("obj:" + obj + "has been released");
      } else {
        objWithTimeout = {
          obj: obj,
          timeout: new Date().getTime() + idleTimeoutMillis
        };
        availableObjects.push(objWithTimeout.obj);
        dispense();
        return scheduleRemoveIdle();
      }
    };
    scheduleRemoveIdle = function() {
      if (!removeIdleScheduled) {
        removeIdleScheduled = true;
        return setTimeout(removeIdle, idleTimeoutMillis);
      }
    };
    removeIdle = function() {
      var aobj, now, obj, toRemove, _i, _j, _len, _len1;
      now = new Date().getTime();
      toRemove = [];
      for (_i = 0, _len = availableObjects.length; _i < _len; _i++) {
        obj = availableObjects[_i];
        if (now > obj.timeout && toRemove.length + factory.min < count) {
          toRemove.push(obj);
        }
      }
      for (_j = 0, _len1 = toRemove.length; _j < _len1; _j++) {
        aobj = toRemove[_j];
        me.destroy(aobj);
      }
      removeIdleScheduled = false;
      if (availableObjects.length > 0) {
        return scheduleRemoveIdle();
      } else {
        return log("all avaiableobects has been removed");
      }
    };
    me.destroy = function(objclient) {
      count -= 1;
      availableObjects = availableObjects.filter(function(objWithTimeout) {
        return objWithTimeout !== objclient;
      });
      factory.destroy(objclient);
      return ensureMinimum();
    };
    me.execcmd = function() {
      var args, callback, cmd, hascallback;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      hascallback = typeof args[args.length - 1] === "function" ? true : false;
      if (!hascallback) {
        callback = function() {};
        args.push(callback);
      } else {
        callback = args[args.length - 1];
      }
      if (typeof args[0] === "string") {
        cmd = args[0];
      } else {
        return callback("error has no cmd", null);
      }
      return me.acquire(function(err, client) {
        if (err) {
          return callback("error while acquire client", null);
        } else {
          args.shift();
          args.pop();
          return client[cmd](args, function(err, result) {
            me.release(client);
            if (err) {
              return callback(null, result);
            } else {
              return callback(err, result);
            }
          });
        }
      });
    };
    ensureMinimum();
    return me;
  };

}).call(this);
