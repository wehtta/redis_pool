// Generated by CoffeeScript 1.7.1
var priorityQueue,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
  __slice = [].slice;

priorityQueue = function() {
  var prio_array;
  prio_array = [];
  return {
    enqueue: function(obj, priority) {
      var max, mid, min, objWithPrio;
      if (priority == null) {
        priority = 1;
      }
      objWithPrio = {
        "obj": obj,
        "priority": priority
      };
      min = max = 0;
      if (prio_array.length === 0) {
        return prio_array[0] = objWithPrio;
      }
      while (true) {
        if (min > max) {
          break;
        }
        mid = (min + max) / 2;
        if (priority > prio_array[mid].priority) {
          min = mid + 1;
        }
        if (priority < prio_array[mid].priority) {
          max = mid - 1;
        }
      }
      return prio_array.splice(mid, 0, objWithPrio);
    },
    dequeue: function() {
      if (prio_array.length > 0) {
        return prio_array.shift()["obj"];
      }
    },
    size: function() {
      return prio_array.length;
    }
  };
};

module.exports.Pool = function(factory, test) {
  var availableObjects, count, createResource, dispense, draining, ensureMinimum, idleTimeoutMillis, log, me, reapInterval, refreshIdle, removeIdle, removeIdleScheduled, removedIdleTimer, scheduleRemoveIdle, waitingClients;
  me = {};
  idleTimeoutMillis = factory.idleTimeoutMillis || 3000;
  reapInterval = factory.reapInterval || 1000;
  refreshIdle = (__indexOf.call(factory, 'refreshIdle') >= 0) ? factory.refreshIdle : true;
  availableObjects = [];
  waitingClients = new priorityQueue();
  count = 0;
  removeIdleScheduled = false;
  removedIdleTimer = null;
  draining = false;
  log = factory.log ? (function(str, level) {
    if (typeof factory.log === 'function') {
      return factory.log(str, level);
    } else {
      return console.log(level + "pool" + factory.name);
    }
  }) : function() {};
  factory.max = parseInt(factory.max, 10);
  factory.min = parseInt(factory.min, 10);
  factory.max = Math.max((isNaN(factory.max) ? 1 : factory.max), 1);
  factory.min = Math.min((isNaN(factory.min) ? 0 : factory.min), factory.max - 1);
  me.acquire = function(callback, priority) {
    if (draining) {
      throw new Error("pool is draining error");
    } else {
      waitingClients.enqueue(callback, priority);
      dispense();
      return count < factory.max;
    }
  };
  dispense = function() {
    var clientCb, objTimeout, waitingCount;
    waitingCount = waitingClients.size();
    log("dispense() clients=" + waitingCount + "available=" + availableObjects, "info");
    if (waitingCount > 0) {
      if (availableObjects.length > 0) {
        objTimeout = availableObjects[0];
        availableObjects.shift();
        clientCb = waitingClients.dequeue();
        clientCb(null, objTimeout.obj);
      }
      if (count < factory.max) {
        return createResource();
      }
    }
  };
  createResource = function() {
    var clientCb;
    count += 1;
    clientCb = waitingClients.dequeue();
    return factory.create(function(err, client) {
      if (err) {
        console.log("createResource error");
        count -= 1;
        if (clientCb) {
          return clientCb(err, null);
        } else {
          return process.nextTick(function() {
            return dispense();
          });
        }
      } else {
        if (clientCb) {
          return clientCb(null, client);
        } else {
          return me.release(client);
        }
      }
    });
  };
  ensureMinimum = function() {
    var _results;
    _results = [];
    while (count < factory.min) {
      _results.push(createResource());
    }
    return _results;
  };
  me.release = function(obj) {
    var objWithTimeout;
    if (availableObjects.some(function(objWithTimeout) {
      return objWithTimeout === obj;
    })) {
      return log("obj:" + obj + "has been released");
    } else {
      objWithTimeout = {
        obj: obj,
        timeout: new Date().getTime() + idleTimeoutMillis
      };
      availableObjects.push(objWithTimeout);
      dispense();
      return scheduleRemoveIdle();
    }
  };
  scheduleRemoveIdle = function() {
    if (!removeIdleScheduled) {
      removeIdleScheduled = true;
      return setTimeout(removeIdle, idleTimeoutMillis);
    }
  };
  removeIdle = function() {
    var aobj, now, obj, toRemove, _i, _j, _len, _len1;
    now = new Date().getTime();
    toRemove = [];
    for (_i = 0, _len = availableObjects.length; _i < _len; _i++) {
      obj = availableObjects[_i];
      if (now > obj.timeout && toRemove.length + factory.min < count) {
        toRemove.push(obj);
      }
    }
    for (_j = 0, _len1 = toRemove.length; _j < _len1; _j++) {
      aobj = toRemove[_j];
      me.destroy(aobj.obj);
    }
    removeIdleScheduled = false;
    if (availableObjects.length > 0) {
      return scheduleRemoveIdle();
    } else {
      return log("all avaiableobects has been removed");
    }
  };
  me.destroy = function(objclient) {
    count -= 1;
    availableObjects = availableObjects.filter(function(objWithTimeout) {
      return objWithTimeout !== objclient;
    });
    factory.destroy(objclient);
    return ensureMinimum();
  };
  me.execcmd = function() {
    var args, callback, cmd, hascallback;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    hascallback = typeof args[args.length - 1] === "function" ? true : false;
    if (!hascallback) {
      callback = function() {};
      args.push(callback);
    } else {
      callback = args[args.length - 1];
    }
    if (typeof args[0] === "string") {
      cmd = args[0];
    } else {
      return callback("error has no cmd", null);
    }
    return me.acquire(function(err, client) {
      if (err) {
        return callback("error while acquire client", null);
      } else {
        args.shift();
        args.pop();
        return client[cmd](args, function(err, result) {
          me.release(client);
          if (err) {
            return callback(null, result);
          } else {
            return callback(err, result);
          }
        });
      }
    });
  };
  ensureMinimum();
  return me;
};
